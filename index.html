<html>
<head>

	
	<!-- Scripts -->
	<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
	<script src="js/libs/underscore.js"></script>
	<script src="js/libs/sylvester.js"></script>
	<script src="js/libs/glUtils.js"></script>
	<script src="js/libs/three.js"></script>
	<script src="js/libs/random-0.26-debug.js"></script>
	<!-- <script src="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script> -->
	<!-- <script src="js/main.js"></script> -->

	<!-- Stylesheets -->
	<!-- <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css"> -->
	<!-- <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap-theme.min.css"> -->
	<link rel="stylesheet" type="text/css" href="style.css">
	
</head>
<body>

		<canvas id="heightmap">
			You're browser doesn't support WebGL....lets try a more modern browser?
		</canvas>

		<canvas id="viewport" tabindex='1'>
			You're browser doesn't support WebGL....lets try a more modern browser?
		</canvas>


		<script id="shader-vs" type="x-shader/x-vertex">
			attribute vec3 aVertexPosition;
			attribute vec4 aVertexSlope;

			//uniform vec3 viewDirection;
			uniform mat4 uMVMatrix;
			uniform mat4 uVMatrix;
			uniform mat4 uPMatrix;

			varying vec3 pos;
			varying float depth;
			varying float distance;

			varying vec3 normal;
			varying float slope;
			varying vec3 band; // {x: height-band, y: height alpha, z: slope alpha}

			void main(void) {
				vec4 position = uPMatrix * uVMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); 
				gl_Position = position;
				pos = aVertexPosition.xyz;
				depth = aVertexPosition.y/50.0;
				distance = sqrt(position.x*position.x + position.z*position.z + position.y*position.y);

				normal = aVertexSlope.xyz;
				slope = aVertexSlope.w;


				// Texture synthesis
				// 	4 [5000+] snow, ice
				// 	3 [4000,5000] snow-mud, volcano
				// 	2 [1000,4000] canyon, deep-cave
				// 	1 [100,1000] bison, rocky
				// 	0 [100-] dirt

				float band0 = 100.0;
				float band1 = 700.0;
				float band2 = 4000.0;
				float band3 = 5000.0;
				float band4 = 7000.0;
				if (pos.y > band3) {
					band.x = 4.0;
					band.y = clamp((pos.y - band3) / (band4 - band3), 0.0, 1.0);
				} else if (pos.y > band2) {
					band.x = 3.0;
					band.y = clamp((pos.y - band2) / (band3 - band2), 0.0, 1.0);
				} else if (pos.y > band1) {
					band.x = 2.0;
					band.y = clamp((pos.y - band1) / (band2 - band1), 0.0, 1.0);
				} else if (pos.y > band0) {
					band.x = 1.0;
					band.y = clamp((pos.y - band0) / (band1 - band0), 0.0, 1.0);
				} else {
					band.x = 0.0;
					band.y = clamp((pos.y) / (band0), 0.0, 1.0);
				}

				band.z = clamp(slope / 800.0, 0.0, 1.0);

			}
		</script>

		<script id="shader-fs" type="x-shader/x-fragment">

			precision mediump float;
			uniform vec3 uColor;

			uniform sampler2D snow;
			uniform sampler2D ice;
			uniform sampler2D snowmud;
			uniform sampler2D volcano;
			uniform sampler2D fault;
			uniform sampler2D canyon;
			uniform sampler2D deepcave;
			uniform sampler2D bison;
			uniform sampler2D rocky;
			uniform sampler2D grass;
			uniform sampler2D gravel;

			uniform vec3 viewDirection;

			varying vec3 pos;
			varying float depth;
			varying float distance;

			varying vec3 normal;
			varying float slope;
			varying vec3 band;

			vec3 applyFog( in vec3  rgb,       // original color of the pixel
						  in float distance ) // camera to point distance
			{
				float b = 0.00005;
				float fogAmount = 1.0 - exp( -distance*b );
				vec3  fogColor  = vec3(0.5,0.6,0.7);
				return mix( rgb, fogColor, fogAmount );
			}

			vec4 triPlanar( sampler2D tex, vec3 coords, vec3 normal ) {
				vec4 color = texture2D( tex, mod(coords.xy, 1.0) ) * normal.z + texture2D( tex, mod(coords.xz, 1.0) ) * normal.y + texture2D( tex, mod(coords.yz, 1.0) ) * normal.x;
				// color /= 3.0;
				return color;
			}
//
// Description : Array and textureless GLSL 2D/3D/4D simplex 
//               noise functions.
//      Author : Ian McEwan, Ashima Arts.
//  Maintainer : ijm
//     Lastmod : 20110822 (ijm)
//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
//               Distributed under the MIT License. See LICENSE file.
//               https://github.com/ashima/webgl-noise
// 

vec3 mod289(vec3 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 mod289(vec4 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 permute(vec4 x) {
     return mod289(((x*34.0)+1.0)*x);
}

vec4 taylorInvSqrt(vec4 r)
{
  return 1.79284291400159 - 0.85373472095314 * r;
}

float snoise(vec3 v)
  { 
  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

// First corner
  vec3 i  = floor(v + dot(v, C.yyy) );
  vec3 x0 =   v - i + dot(i, C.xxx) ;

// Other corners
  vec3 g = step(x0.yzx, x0.xyz);
  vec3 l = 1.0 - g;
  vec3 i1 = min( g.xyz, l.zxy );
  vec3 i2 = max( g.xyz, l.zxy );

  //   x0 = x0 - 0.0 + 0.0 * C.xxx;
  //   x1 = x0 - i1  + 1.0 * C.xxx;
  //   x2 = x0 - i2  + 2.0 * C.xxx;
  //   x3 = x0 - 1.0 + 3.0 * C.xxx;
  vec3 x1 = x0 - i1 + C.xxx;
  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y

// Permutations
  i = mod289(i); 
  vec4 p = permute( permute( permute( 
             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

// Gradients: 7x7 points over a square, mapped onto an octahedron.
// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
  float n_ = 0.142857142857; // 1.0/7.0
  vec3  ns = n_ * D.wyz - D.xzx;

  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)

  vec4 x_ = floor(j * ns.z);
  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

  vec4 x = x_ *ns.x + ns.yyyy;
  vec4 y = y_ *ns.x + ns.yyyy;
  vec4 h = 1.0 - abs(x) - abs(y);

  vec4 b0 = vec4( x.xy, y.xy );
  vec4 b1 = vec4( x.zw, y.zw );

  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;
  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;
  vec4 s0 = floor(b0)*2.0 + 1.0;
  vec4 s1 = floor(b1)*2.0 + 1.0;
  vec4 sh = -step(h, vec4(0.0));

  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

  vec3 p0 = vec3(a0.xy,h.x);
  vec3 p1 = vec3(a0.zw,h.y);
  vec3 p2 = vec3(a1.xy,h.z);
  vec3 p3 = vec3(a1.zw,h.w);

//Normalise gradients
  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;

// Mix final noise value
  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
  m = m * m;
  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
                                dot(p2,x2), dot(p3,x3) ) );
  }

			void main(void) {

				// vec3 blending = abs( normal );
				// blending = normalize(max(blending, 0.00001)); // Force weights to sum to 1.0
				// float b = (blending.x + blending.y + blending.z);
				// blending /= vec3(b, b, b);

				// vec4 tex1 = triPlanar( deepcave, pos*0.01,  blending );
				// vec4 tex2 = triPlanar( fault, pos*0.001, blending );
				// vec4 tex3 = triPlanar( canyon, pos*0.01,  blending );

				// TODO: apply detail texture to each fetch
				vec4 colBase1;
				vec4 colBase2;
				vec4 colSlope1;
				vec4 colSlope2;
				vec4 colDetail;
				float texBaseScale = 0.005;
				float texBaseScale2 = -0.0005;
				float texSlopeScale = 0.001;
				float texSlopeScale2 = -0.0001;
				float texDetailScale = texBaseScale*8.0;

				// 	4 [5000+] snow, ice
				// 	3 [4000,5000] snow-mud, volcano
				// 	2 [1000,4000] canyon, deep-cave
				// 	1 [100,1000] bison, rocky
				// 	0 [100-] dirt
				float bx;
				float by;
				float bz = band.z;
				float bMult;
				float band0 = 500.0;
				float band1 = 700.0;
				float band2 = 3000.0;
				float band3 = 5000.0;
				float band4 = 6000.0;
				float band5 = 10000.0;
				vec2 steepSlopePos = vec2( pos.y, max(pos.x , pos.z)); // TODO: adds really cool effects when
											// used in place of pos.xz on steep slopes (mountains)
				vec3 norm = normalize(normal);
				if (pos.y > band4) {
					bx = 5.0;
					by = clamp((pos.y - band4) / (band5 - band4), 0.0, 1.0);
				} else if (pos.y > band3) {
					bx = 4.0;
					by = clamp((pos.y - band3) / (band4 - band3), 0.0, 1.0);
				} else if (pos.y > band2) {
					bx = 3.0;
					by = clamp((pos.y - band2) / (band3 - band2), 0.0, 1.0);
				} else if (pos.y > band1) {
					bx = 2.0;
					by = clamp((pos.y - band1) / (band2 - band1), 0.0, 1.0);
				} else if (pos.y > band0) {
					bx = 1.0;
					by = clamp((pos.y - band0) / (band1 - band0), 0.0, 1.0);
				} else {
					bx = 0.0;
					by = clamp((pos.y) / (band0), 0.0, 1.0);
				}
				float scaleRocks = 2.0;
				float scaleRocks2 = 4.0;
				float scaleCave  = 0.5;
				float scaleVolcano = 3.0;

				float lightIntensity = 1.0;
				float attenuation = 0.0;
				float shininess = 0.0;

				// TODO: tinting the cave texture on the mountain to closely match the rocks..
				vec4 tintRock = vec4(1.0,1.0,1.0,1.0)*0.2;
				vec4 tintCave = vec4(1.0,1.0,1.0,1.0)*1.0;// vec4( 56.0/250.0, 50.0/250.0, 40.0/250.0, 1.0 ) * 2.0;
				//vec4 tintCave = vec4( 56.0/250.0, 50.0/250.0, 40.0/250.0, 1.0 ) * 1.2;
				if (bx < 1.0) {

					colBase1 = texture2D( fault, pos.xz * texBaseScale );
					colBase1 *= texture2D( fault, pos.xz * texBaseScale2 );

					colBase2 = texture2D( bison,  pos.xz * texBaseScale );
					colBase2 *= texture2D( bison,  pos.xz * texBaseScale2 );

					colSlope1 = texture2D( rocky, pos.xz * texSlopeScale * scaleRocks ) * tintRock;
					colSlope2 = texture2D( rocky,  pos.xz * texSlopeScale * scaleRocks ) * tintRock;

					colDetail = texture2D( gravel, pos.xz * texDetailScale );
					bMult =3.8;
					lightIntensity = 0.25;

				} else if (bx < 2.0) {

					colBase1 = texture2D( bison,  pos.xz * texBaseScale );
					colBase1 *= texture2D( bison, pos.xz * texBaseScale2 );

					colBase2 = texture2D( rocky, pos.xz * texBaseScale );
					colBase2 *= texture2D( rocky,  pos.xz * texBaseScale2 * scaleRocks2 );

					colSlope1 = texture2D( rocky,    pos.xz * texSlopeScale * scaleRocks ) * tintRock;
					colSlope2 = texture2D( deepcave, pos.xz * texSlopeScale * scaleCave ) * tintCave;

					colDetail = texture2D( gravel, pos.xz * texDetailScale );
					bMult = (3.8 - 1.8) * (1.0 - by) + 1.8;
					lightIntensity = 0.25;

				} else if (bx < 3.0) {

					colBase1 = texture2D( rocky,  pos.xz * texBaseScale );
					colBase1 *= texture2D( rocky, pos.xz * texBaseScale2 * scaleRocks2 );

					colBase2 = texture2D( rocky, pos.xz * texBaseScale * scaleRocks );
					colBase2 *= texture2D( rocky,  pos.xz * texBaseScale2 * scaleRocks2 );

					colSlope1 = texture2D( deepcave,  pos.xz * texSlopeScale * scaleCave ) * tintCave;
					colSlope2 = texture2D( deepcave, steepSlopePos * texSlopeScale * scaleCave ) * tintCave;

					colDetail = texture2D( gravel, pos.xz * texDetailScale );
					bMult =1.8;
					lightIntensity = (0.25 - 1.0) * (1.0 - by) + 1.0;


				} else if (bx < 4.0) {

					colBase1 = texture2D( rocky,  pos.xz * texBaseScale * scaleRocks );
					colBase1 *= texture2D( rocky, pos.xz * texBaseScale2 * scaleRocks2 );

					colBase2 = texture2D( snowmud, pos.xz * texBaseScale * 0.2 );
					colBase2 *= texture2D( snowmud,  pos.xz * texBaseScale2 );

					colSlope1 = texture2D( deepcave, steepSlopePos * texSlopeScale * scaleCave ) * tintCave;
					colSlope2 = texture2D( volcano,  pos.xz * texSlopeScale * scaleVolcano );

					colDetail = texture2D( gravel, pos.xz * texDetailScale );
					bMult =1.8;
					lightIntensity = 1.0;//(0.6 - 1.0) * (by - 1.0) + 0.6;
					attenuation = 0.2;
					shininess = 5.0;

				} else if (bx < 5.0) {

					colBase1 = texture2D( snowmud, pos.xz * texBaseScale * 0.2 );
					colBase1 *= texture2D( snowmud, pos.xz * texBaseScale2 );

					colBase2 = texture2D( snow,    pos.xz * texBaseScale );
					colBase2 *= texture2D( snow,  pos.xz * texBaseScale2 );

					colSlope1 = texture2D( volcano, pos.xz * texSlopeScale * scaleVolcano );
					colSlope2 = texture2D( ice,     pos.xz * texSlopeScale );

					colDetail = texture2D( gravel, pos.xz * texDetailScale );
					bMult = (1.8 - 1.0) * (1.0 - by) + 1.0;
					lightIntensity = (0.6 - 1.0) * (by - 1.0) + 0.6;
					attenuation = 0.2;
					shininess = 5.0;

				} else if (bx == 5.0) {

					colBase1 = texture2D( snow, pos.xz * texBaseScale );
					colBase1 *= texture2D( snow, pos.xz * texBaseScale2 );

					colBase2 = texture2D( snow,    pos.xz * texBaseScale );
					colBase2 *= texture2D( snow,  pos.xz * texBaseScale2 );

					colSlope1 = texture2D( ice, pos.xz * texSlopeScale );
					colSlope2 = texture2D( ice,     pos.xz * texSlopeScale );

					colDetail = texture2D( gravel, pos.xz * texDetailScale );
					bMult = 1.0;
					lightIntensity = 0.6;
					attenuation = 0.2;
					shininess = 5.0;

				}

				// float alpha = snoise(pos * 0.1);
				// float alpha2 = snoise(pos * 0.0001) * 0.2;

				// // Noise based bumpmapping
				// vec3 bump = vec3(alpha*0.5 + 0.5);
				// float E = 2.0;
				// vec3 modNormal = vec3( (bump.x-alpha) / E, (bump.y-alpha) / E, (bump.z-alpha) / E);
				// norm = normalize(norm + modNormal);

				// lightIntensity *= 3.0;

				// bMult *= 1.0 + alpha/10.0;
				// lightIntensity *= 1.0 + alpha/10.0;
				// bz = clamp(bz + alpha2, 0.0, 1.0);



				vec4 texBase = colBase1 * (1.0 - by) + colBase2 * by;
				vec4 texSlope = colSlope1 * (1.0 - by) + colSlope2 * by;
				// vec4 tex = texSlope;

				vec4 tex = texBase * (1.0 - bz) + texSlope * bz;
				tex *= bMult;
				// tex *= colDetail * 2.0;

				// tex = vec4(band, 1.0);
				// tex.r /= 4.0;



				// vec4 tex1 = texture2D(fault, pos.xz*0.01);
				// vec4 tex2 = texture2D(deepcave, pos.xz*0.001);

				// vec4 tex = tex1 * tex2 * 2.0;

				vec3 lightCol = vec3(1.0, 1.0, 1.0);
				//vec3 lightCol = vec3(0.9, 0.7, 0.1);
				//vec3 light_pos = vec3(pos.x-300.0, pos.y+180.0, pos.z-300.0);
				//vec3 light_norm = normalize(light_pos-pos);
				vec3 light_norm = normalize(vec3(-4.0, -1.0, 4.0));
				float lDotN = max(dot(norm, -light_norm), 0.0) * 1.0;


				// Specular
				vec3 specularReflection;
				if (lDotN < 0.0 || attenuation == 0.0) { // light source on the wrong side?
					specularReflection = vec3(0.0, 0.0, 0.0); // no specular reflection
				} else { // light source on the right side
					specularReflection = attenuation * tex.rgb * pow(max(0.0, dot(reflect(-light_norm, norm), -viewDirection)), shininess);
				}


				 tex.rgb = tex.rgb * (0.7) + tex.rgb * lightCol * lDotN * lightIntensity + specularReflection;
				 //tex.rgb = tex.rgb * lightCol * lDotN * 1.0;


				// tex.rgb = vec3( pos.y / 5000.0 ); // Altitude map
				// tex.rgb = vec3( slope / 650.0 );	// Slope map


				// tex.rgb += tex3.rgb * slope/650.0;
				// tex.rgb = normalize(normal);

				// tex.rgb = normal;
				// tex.rgb = vec3(slope / 1024.0);

				// tex.rb = vec2(abs(normal) / 250.0);
				// tex.g  = abs(slope) / 250.0;
				// tex.a = 0.9;

				 tex.rgb = applyFog(tex.rgb, distance);
				// tex.rgb *= uColor;
				gl_FragColor = tex;

				// gl_FragColor = texture2D(uSampler, vec2( mod(pos.x*0.01,1.0) , mod(gl_FragCoord.z*0.01,1.0) ));
				// gl_FragColor = vec4( gl_FragCoord.z*depth, 1.0, 1.0, 1.0 );


			}
		</script>


		<script id="skybox-vs" type="x-shader/x-vertex">
			attribute vec3 aVertexCoord;
			attribute vec3 aTexCoord;

			uniform mat4 uMVMatrix;
			uniform mat4 uVMatrix;
			uniform mat4 uPMatrix;

			varying vec3 texPos;
			varying float distance;

			void main(void) {
				vec4 position = uPMatrix * uVMatrix * vec4(aVertexCoord, 1.0); 
				gl_Position = position;

				distance = sqrt(position.x*position.x + position.z*position.z);

				texPos = aTexCoord.xyz;
			}
		</script>

		<script id="skybox-fs" type="x-shader/x-fragment">

			precision mediump float;
			uniform samplerCube TexSampler;

			varying vec3 texPos;
			varying float distance;

			vec3 applyFog( in vec3  rgb,       // original color of the pixel
						  in float distance ) // camera to point distance
			{
				float b = 0.10;
				float fogAmount = 1.0 - 0.4;// exp( -distance*b );
				vec3  fogColor  = vec3(0.5,0.6,0.7);
				return mix( rgb, fogColor, fogAmount );
			}

			void main(void) {
				vec4 tex;

				tex = textureCube(TexSampler, texPos);
				// tex.rgb = applyFog(tex.rgb, distance);
				gl_FragColor = tex;
			}
		</script>


		<script src="js/viewport.js"></script>
		<script>
			$(document).ready(function(){
				//initWebGL();
				//draw();
				generateImage();
				// updateCanvas();
				initViewport();
				begin();

				window['world'] = world;


				var MOVE_FORWARD  = 1<<0,
					MOVE_BACKWARD = 1<<1,
					MOVE_LEFT     = 1<<2,
					MOVE_RIGHT    = 1<<3,
					MOVE_UP       = 1<<4,
					MOVE_DOWN     = 1<<5,
					MOVE_RUNNING  = 1<<6;
				var UI = {
					viewport: {
						mouse: {
							position: {x:0,y:0},
							buttons: 0,
							target: new THREE.Vector3(0,0,0),
							phi: 0.0,
						},
						move: new THREE.Vector3(0,0,0),
						isMoving: 0
					},
					mouse: {
						isDown: false,
						position: {x:0, y:0}
					},
					lastWorldUpdate: (new Date()).getTime(),
				}

				var updateMove = function(){
					if (UI.viewport.isMoving) {

						var move = UI.viewport.move,
							movement = UI.viewport.isMoving;
						move.x = 0; move.y = 0; move.z = 0;
						if ( movement & MOVE_FORWARD )  move.z += 1;
						if ( movement & MOVE_BACKWARD ) move.z -= 1;
						if ( movement & MOVE_LEFT )     move.x -= 1;
						if ( movement & MOVE_RIGHT )    move.x += 1;
						if ( movement & MOVE_UP )       move.y -= 1;
						if ( movement & MOVE_DOWN )     move.y += 1;

						// var qX = new THREE.Quaternion(),
						// 	qY = new THREE.Quaternion();
						// qX.setFromAxisAngle( new THREE.Vector3(0,1,0), Objects.camera.phi );
						// qY.setFromAxisAngle( new THREE.Vector3(1,0,0), -Objects.camera.theta );
						// qX.multiply(qY);
						// qX.z *= -1;
						// move.applyQuaternion(qX);

						// var euler = new THREE.Euler( -Objects.camera.theta, Objects.camera.phi, 0 );
						// move.applyEuler(euler);

						var qX = new THREE.Quaternion(),
							qY = new THREE.Quaternion(),
							qZ = new THREE.Quaternion(),
							m = new THREE.Matrix4();
						qX.setFromAxisAngle( new THREE.Vector3(0,1,0), -Objects.camera.phi );
						qY.setFromAxisAngle( new THREE.Vector3(-1,0,0),-Objects.camera.theta );
						qZ.setFromAxisAngle( new THREE.Vector3(0,0,1), Objects.camera.lambda );
						qY.multiply(qX);
						qY.multiply(qZ);
						m.makeRotationFromQuaternion(qY);
						m.getInverse(m);
						move.applyMatrix4(m);
						// move.applyQuaternion(qY);

						move.x *= -1;
						if ( movement & MOVE_RUNNING ) move.multiplyScalar(1000);
						else move.multiplyScalar(100);
						Objects.camera.position.add(move);
						updateCamera();

						position.y = Objects.camera.position.z/Settings.scaleXZ;
						position.x = Objects.camera.position.x/Settings.scaleXZ;

						var time = (new Date()).getTime();
						if (time - UI.lastWorldUpdate > 50) {
							UI.lastWorldUpdate = time;
							world.update();
						}
						// updateCanvas();
					}

					setTimeout(updateMove, 100);
				};

				updateMove();

				canvas.addEventListener('mousedown', function MouseDownEvent(evt){
					var bounds  = canvas.getBoundingClientRect(),
						mouseY  = evt.clientY - bounds.top,
						mouseX  = evt.clientX - bounds.left;

					UI.mouse.isDown = true;
					UI.mouse.position.x = mouseX;
					UI.mouse.position.y = mouseY;
				});

				canvas.addEventListener('mouseup', function MouseUpEvent(evt){
					UI.mouse.isDown = false;
				});

				canvas.addEventListener('mousemove', function MouseMoveEvent(evt){
					if (UI.mouse.isDown) {
						var bounds  = canvas.getBoundingClientRect(),
							mouseY  = evt.clientY - bounds.top,
							mouseX  = evt.clientX - bounds.left,
							deltaY  = 1.7*2*(mouseY - UI.mouse.position.y),
							deltaX  = 1.7*(mouseX - UI.mouse.position.x);

						position.y += deltaY;
						position.x += deltaX;

						Objects.camera.position.x = Settings.scaleXZ*position.x;
						Objects.camera.position.z = Settings.scaleXZ*position.y;
						updateCamera();

						UI.mouse.position.x = mouseX;
						UI.mouse.position.y = mouseY;

						var time = (new Date()).getTime();
						if (time - UI.lastWorldUpdate > 50) {
							UI.lastWorldUpdate = time;
							world.update();
						}
						// updateCanvas();
					}
				});

				viewportCanvas.addEventListener('mousedown', function MouseDownEvent(evt){

					var bounds  = viewportCanvas.getBoundingClientRect(),
						mouseY  = evt.clientY - bounds.top,
						mouseX  = evt.clientX - bounds.left;

					UI.viewport.mouse.position.x = mouseX;
					UI.viewport.mouse.position.y = mouseY;

					var MOUSE_LOOK = 4,
						MOUSE_MOVE = 1 | MOUSE_LOOK;
					UI.viewport.mouse.buttons |= (1<<evt.button);
					if ((UI.viewport.mouse.buttons & MOUSE_MOVE) === MOUSE_MOVE) {
						UI.viewport.isMoving |= MOVE_FORWARD;
					} else if ((UI.viewport.mouse.buttons & MOUSE_LOOK) === MOUSE_LOOK) {

					}

					evt.preventDefault();
					return false;

				});
				viewportCanvas.oncontextmenu = function(){ return false; };

				viewportCanvas.addEventListener('mouseup', function MouseUpEvent(evt){

					var MOUSE_LOOK = 4,
						MOUSE_MOVE = 1 | MOUSE_LOOK;
					UI.viewport.mouse.buttons = UI.viewport.mouse.buttons & ~(1<<evt.button);
					if ((UI.viewport.mouse.buttons & MOUSE_MOVE) !== MOUSE_MOVE) {
						UI.viewport.isMoving &= ~MOVE_FORWARD;
					}

					evt.preventDefault();
					return false;

				});

				viewportCanvas.addEventListener('mousemove', function MouseMoveEvent(evt){

					var MOUSE_LOOK = 4;
					if (UI.viewport.mouse.buttons & MOUSE_LOOK) {

						var bounds  = viewportCanvas.getBoundingClientRect(),
							mouseY  = evt.clientY - bounds.top,
							mouseX  = evt.clientX - bounds.left,
							deltaY  = 1.7*2*(mouseY - UI.viewport.mouse.position.y),
							deltaX  = 1.7*(mouseX -   UI.viewport.mouse.position.x);



							Objects.camera.phi += deltaX*0.001;
							Objects.camera.phi = Objects.camera.phi % (Math.PI*2.0);

							Objects.camera.theta += deltaY*0.0005;
							if (Objects.camera.theta > Math.PI) Objects.camera.theta = Math.PI;
							if (Objects.camera.theta < -Math.PI)Objects.camera.theta = -Math.PI;
							// Objects.camera.theta = Objects.camera.theta % (Math.PI*1.0);
							// if (Objects.camera.theta < 0) Objects.camera.theta = Math.PI*1.0 - 0.001;
							// if (Objects.camera.phi < 0) Objects.camera.phi = Math.PI*2.0 - 0.001;


							updateCamera();


						UI.viewport.mouse.position.x = mouseX;
						UI.viewport.mouse.position.y = mouseY;
					}

				});

				document.addEventListener('keydown', function KeyDownEvent(evt){
					
					       if (evt.keyCode === 87) {
						UI.viewport.isMoving |= MOVE_BACKWARD;
					} else if (evt.keyCode === 65) {
						UI.viewport.isMoving |= MOVE_LEFT;
					} else if (evt.keyCode === 68) {
						UI.viewport.isMoving |= MOVE_RIGHT;
					} else if (evt.keyCode === 83) {
						UI.viewport.isMoving |= MOVE_UP;
					} else if (evt.keyCode === 16) {
						UI.viewport.isMoving |= MOVE_RUNNING;
					}
				});

				document.addEventListener('keyup', function KeyUpEvent(evt){
					
					       if (evt.keyCode === 87) {
						UI.viewport.isMoving &= ~MOVE_BACKWARD;
					} else if (evt.keyCode === 65) {
						UI.viewport.isMoving &= ~MOVE_LEFT;
					} else if (evt.keyCode === 68) {
						UI.viewport.isMoving &= ~MOVE_RIGHT;
					} else if (evt.keyCode === 83) {
						UI.viewport.isMoving &= ~MOVE_UP;
					} else if (evt.keyCode === 16) {
						UI.viewport.isMoving &= ~MOVE_RUNNING;
					}
				});

			});
		</script>
		<script src="js/generator.js"></script>
</body>
</html>
